#!/bin/bash

WORK_DIR="/opt/miner"
PROG="bin/miner"
FULL_PROG=${WORK_DIR}/${PROG}
LOG="/var/log/miner/startup.log"
USER_SWARM_KEY="/var/lib/user_swarm_key"
MINER_SWARM_KEY="/var/lib/miner/miner/swarm_key"

WATCH_PROG_INTERVAL=10
WATCH_LAG_INTERVAL=3600
MAX_LAG=250
MIN_FREE_SPACE=2048 # MB
SYNC_URL="https://msync.syncrob.it/"


test -n "${OS_VERSION}" || source /etc/init.d/base


free_space() {
    df -m /data | tail -n1 | tr -s ' ' | cut -d ' ' -f 4
}

watch_prog() {
    count=0
    while true; do
        sleep ${WATCH_PROG_INTERVAL}
        if ! ps aux | grep ${FULL_PROG} | grep -vq grep; then
            panic_action miner "service dead"
            break
        fi
        free_mb=$(free_space)
        if [[ "${free_mb}" -lt ${MIN_FREE_SPACE} ]]; then
            panic_action miner "low disk space"
            break
        fi
    done
}

sync_from_snapshot() {
    msg_begin "Synchronizing miner data"
    
    if ! data=$(curl --fail -m 300 -s ${SYNC_URL}); then
        msg_fail "metadata download failed"
        return 1
    fi
    if ! block_height=$(jq -r '.blockHeight' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! file=$(jq -r '.fileUri' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! check_sum=$(jq -r '.checkSum.md5' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! curl --fail -m 300 -sSL "${file}" -o /tmp/snapshot.bin; then
        msg_fail "snapshot download failed"
        return 1
    fi
    local_check_sum=$(md5sum /tmp/snapshot.bin | awk '{print $1}')
    if [[ "${local_check_sum}" != "${check_sum}" ]]; then
        msg_fail "invalid checksum"
        return 1
    fi

    # Ignore errors from snapshot load command; it actually does the job in spite of reported errors
    export NODETOOL_TIMEOUT=300000
    ${FULL_PROG} snapshot load /tmp/snapshot.bin &>/dev/null
    msg_done
}

watch_lag() {
    while true; do
        sleep ${WATCH_LAG_INTERVAL}
        current_height=$(curl -s https://api.helium.io/v1/blocks/height | jq .data.height)
        test $? == 0 || continue
        our_height=$(${FULL_PROG} info height | awk '{print $2}')
        test $? == 0 || continue
        dif=$(expr ${current_height} - ${our_height})
        if [[ ${dif} -le ${MAX_LAG} ]]; then
            continue
        fi
        panic_action miner "lag is ${dif} > ${MAX_LAG}"
    done
}

start() {
    # If we don't have enough storage space, remove miner data and do a resync
    free_mb=$(free_space)
    if [[ "${free_mb}" -lt ${MIN_FREE_SPACE} ]]; then
        msg_begin "Removing miner data due to low space"
        msg_done "${free_mb} MB"
        rm -rf /var/lib/miner
    fi
    
    msg_begin "Starting miner"

    if ! [[ -e /dev/i2c-1 ]] && ! [[ -s ${USER_SWARM_KEY} ]]; then
        msg_fail "no I2C device"
        return
    fi

    if ! [[ -s /var/run/vpnpasswd ]]; then
        msg_fail "no provisioned ECC device"
        panic_action miner "no provisioned ECC device"
        return 1
    fi

    cd ${WORK_DIR}
    mkdir -p $(dirname ${LOG})
    
    export RUNNER_LOG_DIR="/var/log/miner"
    export ERL_CRASH_DUMP="/var/log/miner"
    export ERL_FULLSWEEP_AFTER=5
    export HOME=/var/run
    ulimit -n 8192
    
    # If user swarm key is present, configure miner to use it instead of ECC
    RELX_CONFIG_PATH="/opt/miner/releases/0.1.0/sys"
    if [[ -s ${USER_SWARM_KEY} ]]; then
        RELX_CONFIG_PATH+=".noecc"

        # If swarm key has changed, we need to resync
        new_sk_hash=$(md5sum ${USER_SWARM_KEY} | cut -d ' ' -f 1)
        test -s ${MINER_SWARM_KEY} && old_sk_hash=$(md5sum ${MINER_SWARM_KEY} | cut -d ' ' -f 1)
        test "${old_sk_hash}" == "${new_sk_hash}" || sync_needed="true"
        
        # Copy user swarm key to miner swarm key location
        mkdir -p $(dirname ${MINER_SWARM_KEY})
        cp ${USER_SWARM_KEY} ${MINER_SWARM_KEY}
    fi
    RELX_CONFIG_PATH+=".config"
    export RELX_CONFIG_PATH
    
    public_keys=$(${PROG} print_keys)
    if [[ $? != 0 ]]; then
        msg_fail "failed to print public key"
        panic_action miner "failed to print public key"
        return 1
    fi
    
    test -d "/var/lib/miner/blockchain.db" || sync_needed="true"
    
    # We need the public key information for gateway config
    echo $public_keys > /var/run/public_keys

    nice -n 10 ${PROG} foreground &>> ${LOG} &
    watch_prog &
    watch_lag &

    test -s ${USER_SWARM_KEY} && msg_done "with user swarm key" || msg_done "with ECC"
    
    if [[ "${sync_needed}" == "true" ]]; then
        if ! sync_from_snapshot; then
            panic_action miner "sync from snapshot failed"
            return 1
        fi
    fi
}

stop() {
    msg_begin "Stopping miner"
    
    base_prog=$(basename ${PROG})
    if killall -q ${base_prog}; then
        # Allow 2 seconds for a gracefulish shutdown
        sleep 2
        msg_done
    else
        msg_fail
    fi
    
    # Kill any remainings with SIGKILL
    ps | grep miner | grep -v $$ | grep -v grep | tr -s ' ' | sed -e 's/^\s//' | cut -d ' ' -f 1 | xargs -r kill -9
}

case "$1" in
    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
esac

exit $?
