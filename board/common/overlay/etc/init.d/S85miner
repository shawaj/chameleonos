#!/bin/bash

WORK_DIR="/opt/miner"
PROG="bin/miner"
FULL_PROG=${WORK_DIR}/${PROG}
LOG="/var/log/miner/startup.log"
USER_SWARM_KEY="/var/lib/user_swarm_key"
MINER_SWARM_KEY="/var/lib/miner/miner/swarm_key"
SYS_CONF="/opt/miner/releases/0.1.0/sys.config"
USER_CONF="/data/etc/miner_sys.config"
NAT_CONF="/data/etc/nat.conf"
HARDWARE_CONF="/var/run/hardware.conf"

WATCH_PROG_INTERVAL=10
WATCH_LAG_INTERVAL=3600
WATCH_LAG_INTERVAL_STARTUP=300
NETWORK_TIMEOUT=3600
MAX_LAG=250
MIN_FREE_SPACE=2048 # MB
MIN_FREE_SPACE_LEEWAY=512 # MB
SYNC_URL="https://msync.syncrob.it/"
FORCE_RESYNC_FILE="/var/lib/miner/force_resync"
DEF_PORT=44158


test -n "${OS_VERSION}" || source /etc/init.d/base

test -s ${NAT_CONF} && source ${NAT_CONF}

source ${HARDWARE_CONF}


free_space() {
    df -m /data | tail -n1 | tr -s ' ' | cut -d ' ' -f 4
}

get_lag() {
    current_height=$(curl --silent https://api.helium.io/v1/blocks/height | jq .data.height)
    test $? == 0 || return
    our_height=$(${FULL_PROG} info height | awk '{print $2}')
    test $? == 0 && [[ "${current_height}" =~ ^[0-9]+$ ]] && [[ "${our_height}" =~ ^[0-9]+$ ]] || return
    expr ${current_height} - ${our_height}
}

force_sync() {
    mkdir -p $(dirname ${FORCE_RESYNC_FILE}) && touch ${FORCE_RESYNC_FILE}
}

watch_prog() {
    # During normal running, we add an extra leeway when checking for free space,
    # to make sure the free space check at next reboot will fail and do a resync.
    min_free_space_watch=$((${MIN_FREE_SPACE} + ${MIN_FREE_SPACE_LEEWAY})) # MB
    while true; do
        sleep ${WATCH_PROG_INTERVAL}
        if ! ps aux | grep ${FULL_PROG} | grep -vq grep; then
            force_sync
            panic_action miner "service dead"
            break
        fi
        free_mb=$(free_space)
        if [[ "${free_mb}" -lt ${min_free_space_watch} ]]; then
            panic_action miner "low disk space"
            break
        fi
    done
}

watch_lag() {
    startup=true
    while true; do
        if [[ ${startup} == true ]]; then
            # Sleep for a smaller amount of time at startup so that we detect unsynced miner earlier
            sleep ${WATCH_LAG_INTERVAL_STARTUP}
            startup=false
        else
            sleep ${WATCH_LAG_INTERVAL}
        fi
        
        lag=$(get_lag)
        test -n "${lag}" || continue
        if [[ ${lag} -le ${MAX_LAG} ]]; then
            continue
        fi
        force_sync
        panic_action miner "lag is ${lag} > ${MAX_LAG}"
    done
}

sync_from_snapshot() {
    msg_begin "Synchronizing miner data"
    
    # Kill any existing sync session
    ps aux | grep curl | grep snapshot.bin | sed -e 's/^\s//' | cut -d ' ' -f 1 | xargs -r kill
    ps aux | grep 'snapshot load' | sed -e 's/^\s//' | cut -d ' ' -f 1 | xargs -r kill
    
    if ! data=$(curl --fail -m 300 --silent --show-error --location-trusted ${SYNC_URL}); then
        msg_fail "metadata download failed"
        return 1
    fi
    if ! block_height=$(jq -r '.blockHeight' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! file=$(jq -r '.fileUri' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! check_sum=$(jq -r '.checkSum.md5' <<< ${data}); then
        msg_fail "metadata parsing failed"
        return 1
    fi
    if ! curl --fail -m 600 --silent --show-error --location-trusted "${file}" -o /tmp/snapshot.bin; then
        msg_fail "snapshot download failed"
        return 1
    fi
    local_check_sum=$(md5sum /tmp/snapshot.bin | awk '{print $1}')
    if [[ "${local_check_sum}" != "${check_sum}" ]]; then
        msg_fail "invalid checksum"
        return 1
    fi
    
    # Avoid panic reboots during snapshot load
    panic_inhibit

    # Ignore errors from snapshot load command; it actually does the job in spite of reported errors
    export NODETOOL_TIMEOUT=300000
    ${FULL_PROG} snapshot load /tmp/snapshot.bin &>/dev/null
    msg_done
}

start() {
    # If we don't have enough storage space, remove miner data and do a resync
    free_mb=$(free_space)
    if [[ "${free_mb}" -lt ${MIN_FREE_SPACE} ]]; then
        msg_begin "Removing miner data due to low space"
        msg_done "${free_mb} MB"
        rm -rf /var/lib/miner
    fi
    
    if [[ -f ${FORCE_RESYNC_FILE} ]]; then
        msg_begin "Forcing miner data resync"
        msg_done
        rm -rf /var/lib/miner
    fi
    
    msg_begin "Starting miner"

    if ! [[ -e /dev/i2c-1 ]] && ! [[ -s ${USER_SWARM_KEY} ]]; then
        msg_fail "no I2C device"
        return
    fi

    if ! [[ -s /var/run/vpnpasswd ]]; then
        msg_fail "no provisioned ECC device"
        panic_action miner "no provisioned ECC device"
        return 1
    fi

    cd ${WORK_DIR}
    mkdir -p $(dirname ${LOG})
    
    export RUNNER_LOG_DIR="/var/log/miner"
    export ERL_CRASH_DUMP="/var/log/miner"
    export ERL_FULLSWEEP_AFTER=5
    export HOME=/var/run
    export RELX_CONFIG_PATH="/var/run/miner_sys.config"
    ulimit -n 8192
    
    # Use custom config, if present
    if [[ -s ${USER_CONF} ]]; then
        cp ${USER_CONF} ${RELX_CONFIG_PATH}
    else
        cp ${SYS_CONF} ${RELX_CONFIG_PATH}
        
        # Adjust dirs
        sed -ri 's;base_dir, ".*";base_dir, "/var/lib/miner";' ${RELX_CONFIG_PATH}
        sed -ri 's;onboarding_dir, ".*";onboarding_dir, "/boot";' ${RELX_CONFIG_PATH}
        
        # If user swarm key is present, configure miner to use it instead of ECC
        if [[ -s ${USER_SWARM_KEY} ]]; then
            sed -ri 's/(.*key_slot.*)/%%\1/' ${RELX_CONFIG_PATH}

            # If swarm key has changed, we need to resync
            new_sk_hash=$(md5sum ${USER_SWARM_KEY} | cut -d ' ' -f 1)
            test -s ${MINER_SWARM_KEY} && old_sk_hash=$(md5sum ${MINER_SWARM_KEY} | cut -d ' ' -f 1)
            test "${old_sk_hash}" == "${new_sk_hash}" || sync_needed="true"
            
            # Copy user swarm key to miner swarm key location
            mkdir -p $(dirname ${MINER_SWARM_KEY})
            cp ${USER_SWARM_KEY} ${MINER_SWARM_KEY}
            
        # Configure ECC address and slot
        else
            sed -ri "s/key_slot, [[:digit:]]+/key_slot, ${ECC_SLOT}/" ${RELX_CONFIG_PATH}
            sed -ri "s/address, 16#[[:digit:]]+/address, 16#${ECC_ADDRESS:2}/" ${RELX_CONFIG_PATH}
        fi
        
        if [[ -n "${NAT_EXTERNAL_PORT}" ]]; then
            NAT_INTERNAL_PORT=${NAT_INTERNAL_PORT:-${DEF_PORT}}
            if [[ -z "${NAT_EXTERNAL_IP}" ]]; then
                NAT_EXTERNAL_IP=$(curl --silent --show-error --location-trusted --fail https://ifconfig.co)
            fi
            if [[ -z "${NAT_INTERNAL_IP}" ]]; then
                eth_addr=$(
                    ip addr show dev eth0 2>/dev/null | grep inet | tr -s ' ' | sed -r 's/^\s+//' | \
                    cut -d ' ' -f 2 | grep -iv fe80 | sed 'N;s/\n/, /'
                )
                wlan_addr=$(
                    ip addr show dev wlan0 2>/dev/null | grep inet | tr -s ' ' | sed -r 's/^\s+//' | \
                    cut -d ' ' -f 2 | grep -iv fe80 | sed 'N;s/\n/, /'
                )
                addr=${eth_addr:-${wlan_addr}}
                NAT_INTERNAL_IP=$(cut -d / -f 1 <<< ${addr})
            fi
            NAT_INTERNAL_IP=$(tr . , <<< ${NAT_INTERNAL_IP})
            NAT_EXTERNAL_IP=$(tr . , <<< ${NAT_EXTERNAL_IP})
            mapping="#{{{${NAT_INTERNAL_IP}},${NAT_INTERNAL_PORT}} => {{${NAT_EXTERNAL_IP}},${NAT_EXTERNAL_PORT}}}}"
            sed -ri "s/(\s+)(\{node_aliases,)/\1{nat_map, ${mapping},\n\1\2/" ${RELX_CONFIG_PATH}
        fi
        
        if [[ -n "${NAT_INTERNAL_PORT}" ]]; then
            sed -ri "s/\{port, ${DEF_PORT}\}/{port, ${NAT_INTERNAL_PORT}}/" ${RELX_CONFIG_PATH}
        fi
    fi

    # We need the public key information for gateway config & more
    public_keys=$(${PROG} print_keys)
    if [[ $? != 0 ]]; then
        msg_fail "failed to print public key"
        panic_action miner "failed to print public key"
        return 1
    fi    
    echo $public_keys > /var/run/public_keys
    
    # Start the miner
    nice -n 10 ${PROG} foreground &>> ${LOG} &
    watch_prog &
    watch_lag &

    test -s ${USER_SWARM_KEY} && msg_done "with user swarm key" || msg_done "with ECC"
    test -d "/var/lib/miner/blockchain.db" || sync_needed="true"

    # Wait for a network connection
    msg_begin "Waiting for network connection"
    connmand-wait-online --timeout=${NETWORK_TIMEOUT}
    if [[ $? != 0 ]]; then
        msg_fail "no network connection"
        panic_action miner "no network connection"
        return 1
    fi
    msg_done "connected"

    if [[ "${sync_needed}" == "true" ]]; then
        if ! sync_from_snapshot; then
            rm -rf /var/lib/miner
            panic_action miner "sync from snapshot failed"
            return 1
        fi
    fi
}

stop() {
    msg_begin "Stopping miner"
    
    base_prog=$(basename ${PROG})
    if killall -q ${base_prog}; then
        # Allow 2 seconds for a gracefulish shutdown
        sleep 2
        msg_done
    else
        msg_fail
    fi
    
    # Kill any remainings with SIGKILL
    ps | grep miner | grep -v $$ | grep -v grep | tr -s ' ' | sed -e 's/^\s//' | cut -d ' ' -f 1 | xargs -r kill -9
}

case "$1" in
    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
esac

exit $?
