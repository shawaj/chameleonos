#!/usr/bin/env python

import base64
import binascii
import hashlib
import os
import sys
import time

import pyatecc


ECC_SLOT = 0
RETRIES = 5


def get_unit_serial_number():
    with open('/proc/cpuinfo', 'rt') as f:
        for line in f:
            if line.startswith('Serial'):
                return line.strip()[-8:]
    
    raise RuntimeError('Could not read CPU serial number')


def make_password(user_swarm_key=None):
    now = int(time.time())
    cpu_serial_number = get_unit_serial_number()
    if user_swarm_key:
        user_swarm_key_hex = binascii.hexlify(user_swarm_key)
        to_hash = f'{now}.{cpu_serial_number}.{user_swarm_key_hex}'
        signature = hashlib.sha256(to_hash.encode()).digest()

    else:
        atecc = pyatecc.ATECC(1)
        ecc_serial_number = atecc.serial_number.lower()
        to_hash = f'{now}.{cpu_serial_number}.{ecc_serial_number}'
        to_sign = hashlib.sha256(to_hash.encode()).digest()
        signature = atecc.ecdsa_sign(ECC_SLOT, to_sign)

    signature_b32 = base64.b32encode(signature).decode()
    password = f'{now}.{signature_b32}'
    
    return password


if __name__ == '__main__':
    user_swarm_key_file = None
    if len(sys.argv) > 1:
        user_swarm_key_file = sys.argv[1]
    if user_swarm_key_file and os.path.exists(user_swarm_key_file):
        password = make_password(open(user_swarm_key_file, 'rb').read())

    else:
        for _ in range(RETRIES):
            try:
                password = make_password()
                break
            
            except Exception:
                time.sleep(0.5)

        else:
            raise RuntimeError('Timeout when talking to ECC')

    print(password)
